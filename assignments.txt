-------------------------------------------------------------------------------------------

Assignment 2: Testing and coverage

In this part you are going to write test methods to verify that the code you wrote in the previous parts of your assignment fully works as intended.
Within the same Directory as app.py create python test files for each python class (not including app.py). So if you implemented part1 using only Gameboard.py
then you would only need to make one file test_Gameboard.py. If you have another py file called foo.py then you would also need to make a separate test file for
it called test_foo.py

Once you create these files `import unittest`. It should already come with visual studio so no need for pip installing anything.

Next, you need to define a test class. Using test_Gameboard.py as an example the way to implement the class would be as follows:
"class Test_TestGameboard(unittest.TestCase):"

within this class definition is where you will create your test methods to verify that 1 they work and catch edge cases as intended, and 
2 your implementation covers as many branches as possible.

To test your classes use the keyboard shortcut "Ctrl + shift + P" for windows or "cmd+shift+P" on Mac to bring up the command Palette.
Enter "Python: Configure Tests" and select unittest. You will then be prompted to select the directory of where your tests are located and finally you need to
choose "test_*.py" option because your file names should have the form test_<name of file>.py

This will allow you to individually test methods without having to wait for all of them to be tested.
To test all methods and to view coverage do the following.

1. python <name of test file> will run your test file and tell you how many passed
2. In terminal enter "coverage run -m unittest discover". This will run all tests and figure out the coverage.
3. enter "coverage html" this will generate a folder called htmlcov which will generate an html file for every test file you created. Open the html file in browser
by double clicking. The html page will highlight in red which lines of code haven't been hit and give you a percent of how much of the file has been tested.
You want this number to be as close to 100% as possible.

Finally, we need to test bugs. To do this we are going to use flake8. open up command palette again in Visual Studio Code "Ctrl + shift + P" for Windows or "cmd+shift+P" on Mac. Enter "lint" and select "Python: Select Linter" and then select flake8. To run flake8 make sure you are in the project directory
and enter the command "flake8 > bugs.txt" this will run flake8 on all python files and then output the results into a txt called bugs.txt.
This bugs.txt file will identify all of the lines and files that have potential bugs in them and tell you what is causing the issue.

Correct implementation will create a blank bugs.txt file since there would be no bugs

Documentation for coverage and flake8 if you are interested:
https://coverage.readthedocs.io/en/coverage-5.5/ 
https://flake8.pycqa.org/en/latest/


------------------------------------------------------------------------------------------------------------------------------------------------------------------
Assignment 3: Database

The last part of the project is to incorporate a database such that if the game closes for any reason, you can pick and from where you left off.
In db.py you are already given code that Init's the database table and one that completely deletes it. It is up to you to implement the add() and the getMove()
methods.

The database takes has 6 columns. (current_turn, board, winner, player1, player2, remaining_moves) in that respective order. All columns are type TEXT besides
remaining_moves which is type INT.

When a game starts it should pick up from the last time it was played. After every move from either player, the database should update to reflect the newest move.

After implementing the database add a unittest file and run the coverage tests.

sqlite3 documentation:
https://docs.python.org/3/library/sqlite3.html


